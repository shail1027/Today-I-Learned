## Python Data Structures Time Complexity

### 1. List (리스트)
- **구조**: 동적 배열
- **주요 연산과 시간 복잡도**:
  - **인덱싱**: O(1)
    - 리스트의 특정 인덱스에 접근하는 것은 상수 시간에 처리된다.
  - **앱펜드 (append)**: O(1) (평균적으로, amortized)
    - 리스트 끝에 요소를 추가하는 경우, 일반적으로 상수 시간이지만, 내부적으로 메모리 재할당이 발생하면 최악의 경우 O(n)이 될 수 있다.
  - **삽입/삭제 (insert, pop, remove)**: O(n)
    - 중간에 삽입하거나 삭제할 때, 나머지 요소들을 이동시켜야 하므로 선형 시간 소요.
  - **검색 (in, index)**: O(n)
    - 리스트를 처음부터 끝까지 검색해야 하므로 최악의 경우 O(n).

<br>
<hr>
<br>

### 2. Tuple (튜플)
- **구조**: 불변(immutable) 리스트
- **주요 연산과 시간 복잡도**:
  - **인덱싱**: O(1)
    - 리스트와 동일하게 특정 인덱스에 접근은 상수 시간.
  - **반복(iteration)**: O(n)
    - 모든 요소를 순회할 때 선형 시간 소요.
  - **불변성**: 한 번 생성된 후에는 변경할 수 없으므로, 수정 관련 연산은 없으며, 새로운 튜플을 생성하는 경우 전체 요소를 복사해야 하므로 O(n)이 될 수 있다.
  
<br>
<hr>
<br>

### 3. Dictionary (딕셔너리)
- **구조**: 해시 테이블 기반
- **주요 연산과 시간 복잡도**:
  - **삽입, 삭제, 조회**: O(1) 평균
    - 해시 함수를 사용하여 키에 접근하므로 평균적으로 상수 시간.
  - **최악의 경우**: O(n)
    - 해시 충돌이 심한 경우, 모든 키를 순차 검색해야 할 수도 있으나, 이는 드문 경우이다.

<br>
<hr>
<br>

### 4. Set (셋)
- **구조**: 해시 테이블 기반 (딕셔너리와 유사하나, 값만 저장)
- **주요 연산과 시간 복잡도**:
  - **삽입, 삭제, 멤버십 테스트**: O(1) 평균
    - 키(요소)를 해시 함수를 통해 처리하므로 평균적으로 상수 시간.
  - **최악의 경우**: O(n)
    - 해시 충돌로 인해 전체 요소를 검색해야 할 경우가 있을 수 있다.
